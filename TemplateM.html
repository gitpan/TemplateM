<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>TemplateM - *ML templates processing module</title>
<link rev="made" href="mailto:" />
</head>

<body style="background-color: white">

<p><a name="__index__"></a></p>
<!-- INDEX BEGIN -->

<ul>

	<li><a href="#name">NAME</a></li>
	<li><a href="#version">VERSION</a></li>
	<li><a href="#synopsis">SYNOPSIS</a></li>
	<li><a href="#abstract">ABSTRACT</a></li>
	<li><a href="#terms">TERMS</a></li>
	<ul>

		<li><a href="#scheme">Scheme</a></li>
		<li><a href="#template">Template</a></li>
		<li><a href="#directive">Directive</a></li>
		<li><a href="#structure">Structure</a></li>
		<li><a href="#label">Label</a></li>
	</ul>

	<li><a href="#description">DESCRIPTION</a></li>
	<ul>

		<li><a href="#schemes">SCHEMES</a></li>
		<li><a href="#constructor">CONSTRUCTOR</a></li>
		<li><a href="#default_scheme_methods_(basic_methods)">DEFAULT SCHEME METHODS (BASIC METHODS)</a></li>
		<ul>

			<li><a href="#cast">cast</a></li>
			<li><a href="#cast_loop">cast_loop</a></li>
			<li><a href="#finalize">finalize</a></li>
			<li><a href="#cast_if">cast_if</a></li>
			<li><a href="#html">html</a></li>
		</ul>

		<li><a href="#galore_scheme_methods">GALORE SCHEME METHODS</a></li>
		<ul>

			<li><a href="#stash">stash</a></li>
			<li><a href="#start_and_finish">start and finish</a></li>
			<li><a href="#loop">loop</a></li>
			<li><a href="#ifelse">ifelse</a></li>
			<li><a href="#output">output</a></li>
			<li><a href="#html">html</a></li>
		</ul>

		<li><a href="#templatem's_and_ssi_directives">TEMPLATEM'S AND SSI DIRECTIVES</a></li>
	</ul>

	<li><a href="#environment">ENVIRONMENT</a></li>
	<li><a href="#bugs">BUGS</a></li>
	<li><a href="#see_also">SEE ALSO</a></li>
	<li><a href="#diagnostics">DIAGNOSTICS</a></li>
	<li><a href="#history">HISTORY</a></li>
	<li><a href="#todo">TODO</a></li>
	<li><a href="#thanks">THANKS</a></li>
	<li><a href="#author">AUTHOR</a></li>
	<li><a href="#copyrights">COPYRIGHTS</a></li>
</ul>
<!-- INDEX END -->

<hr />
<p>
</p>
<h1><a name="name">NAME</a></h1>
<p>TemplateM - *ML templates processing module</p>
<p>
</p>
<hr />
<h1><a name="version">VERSION</a></h1>
<p>Version 2.20</p>
<p>14 April 2008</p>
<p>
</p>
<hr />
<h1><a name="synopsis">SYNOPSIS</a></h1>
<pre>
    use TemplateM;
    use TemplateM 2.20;
    use TemplateM 'galore';
    use TemplateM 2.20 'galore';</pre>
<pre>
    $template = new TemplateM(
        -file =&gt; 'template_file',
        -login =&gt; 'user_login',
        -password =&gt; 'user_password',
        -cache =&gt; 'cache_files_absolute_path',
        -timeout =&gt; 'timeout',
        -header =&gt; 'HTTP_header',
        -template =&gt; 'HTTP_content'
        );
    my %htm = ( ... );
    $template = new TemplateM(\%htm);</pre>
<pre>
    # DEFAULT:</pre>
<pre>
    $template-&gt;cast({label1=&gt;value1, label2=&gt;value2, ... });
    my %h = ( ... );
    $template-&gt;cast(\%h);</pre>
<pre>
    $template-&gt;cast_loop (&quot;block_label&quot;, {label1=&gt;value1, label2=&gt;value2, ... });
    $template-&gt;finalize (&quot;block_label);
    
    $template-&gt;cast_if('block_label', predicate);</pre>
<pre>
    # GALORE:</pre>
<pre>
    my $block = $template-&gt;start('block_label');</pre>
<pre>
    $block-&gt;loop(label1 =&gt; 'A', label2 =&gt; 'B', ... );</pre>
<pre>
    $template-&gt;stash(label1 =&gt; 'value1', label2 =&gt; 'value2', ...);
    $block-&gt;stash(label1 =&gt; 'value1', ... );</pre>
<pre>
    $template-&gt;ifelse(&quot;ifblock_label&quot;, $predicate)
    $block-&gt;ifelse(&quot;ifblock_label&quot;, $predicate)</pre>
<pre>
    $block-&gt;output;</pre>
<pre>
    $block-&gt;finish;</pre>
<pre>
    $template-&gt;output;
    $template-&gt;html(&quot;Content-type: text/html\n\n&quot;);</pre>
<p>
</p>
<hr />
<h1><a name="abstract">ABSTRACT</a></h1>
<p>The TemplateM module means for text templates processing in XML, HTML, TEXT and so on formats. TemplateM is the alternative to most of standard modules, and it can accomplish remote access to template files, has simple syntax, small size and flexibility. Then you use TemplateM, functionality and data are completely separated, this is quality of up-to-date web-projects.</p>
<p>
</p>
<hr />
<h1><a name="terms">TERMS</a></h1>
<p>
</p>
<h2><a name="scheme">Scheme</a></h2>
<p>Set of methods prodiving process template's structures.</p>
<p>
</p>
<h2><a name="template">Template</a></h2>
<p>File or array of data which represents the set of instructions, directives and tags of markup languages and statistics.</p>
<p>
</p>
<h2><a name="directive">Directive</a></h2>
<p>Name of structure in a template for substitution. There are a number of directives:
</p>
<pre>

    cgi, val, do, loop, if, else</pre>
<p>
</p>
<h2><a name="structure">Structure</a></h2>
<p>Structure is the tag or the group of tags in a template which defining a scope of substitution.
The structure consist of tag &lt;!-- --&gt; and formatted content:
</p>
<pre>

    DIRECTIVE: LABEL</pre>
<p>The structure can be simple or complex. Simple one is like this:</p>
<pre>
    &lt;!-- cgi: foo --&gt;
    or
    &lt;!-- val: bar --&gt;</pre>
<p>Complex structure is the group of simple structures which constitutive a ``section''</p>
<pre>
    &lt;!-- do: foo --&gt;
    ...
    &lt;!-- loop: foo --&gt;</pre>
<pre>
    even so:</pre>
<pre>
    &lt;!-- if: foo --&gt;
    ...
    &lt;!-- endif: foo --&gt;
    &lt;!-- else: foo --&gt;
    ...
    &lt;!-- endelse: foo --&gt;</pre>
<p>
</p>
<h2><a name="label">Label</a></h2>
<p>This is identifier of structure. E.g. foo, bar, baz</p>
<pre>
    &lt;!-- cgi: foo --&gt;</pre>
<p>
</p>
<hr />
<h1><a name="description">DESCRIPTION</a></h1>
<p>
</p>
<h2><a name="schemes">SCHEMES</a></h2>
<p>While defining use it can specify 2 accessible schemes - galore or default.
It is not obligatory to point at default scheme.</p>
<p>Default scheme is basic and defines using of basic methods:</p>
<p><code>cast, cast_if, cast_loop, finalize and html</code></p>
<p>Default scheme methods is expedient for small-datasize projects.</p>
<p>Galore scheme is the alternative for base scheme and it defines own set of methods:</p>
<p><code>stash, start, loop, finish, ifelse, output and html</code></p>
<p>In order to get knowing which of schemes is activated you need to invoke methods either <code>module()</code> or <code>scheme()</code></p>
<pre>
    my $module = $template-&gt;module;
    my $module = $template-&gt;scheme;</pre>
<p>
</p>
<h2><a name="constructor">CONSTRUCTOR</a></h2>
<p>Constructor <code>new()</code> is the principal method independent of selected scheme. Almost simple way to use the constructor is:</p>
<pre>
    my $template = new TemplateM( -cache =&gt; &quot;.&quot; );</pre>
<p>This invoking takes directive to use template file named index.shtml in current directory and uses the current directory for cache files storage.</p>
<p>Below is the attribute list of constructor:</p>
<dl>
<dt><strong><a name="item_file">file</a></strong><br />
</dt>
<dd>
<strong>Template filename</strong> is the filename or locations of a template. Supports relative or absolute pathes,
and also template file locator. Relative path can forestall with ./ prefix or without it.
Absolute path must be forestall with / prefix. Template file locator is the URI formatted string.
If the file is missed, it use ``index.shtml' from current directory as default value.
</dd>
<p></p>
<dt><strong><a name="item_login_and_password">login and password</a></strong><br />
</dt>
<dd>
<strong>User Login</strong> and <strong>user password</strong> are data for standard HTTP-authorization.
Login and password will be used when the template defined via locator and when remote access is
protected by HTTP-authorization of remote server. When user_login is missed the access to remote
template file realizes simplified scheme, without basic HTTP-authorization.
</dd>
<p></p>
<dt><strong><a name="item_cache">cache</a></strong><br />
</dt>
<dd>
<strong>Cache</strong> is the absolute or relative path to directory for cache files storage. This directory needs to have a permission to read and write files.
When <strong>cache</strong> is missed caching is disabled. Caching on is recommended for faster module operations.
</dd>
<p></p>
<dt><strong><a name="item_timeout">timeout</a></strong><br />
</dt>
<dd>
<strong>Timeout</strong> is the period of cache file keeping in integer seconds.
When the value is missed cache file ``compiles'' once and will be used as template.
Positive value has an effect only then template file is dynamic and it changes in time.
Previous versions of the module sets value 20 instead 0 by default.
It had to set the value -1 for ``compilation'' disabling.
For current version of the module value can be 0 or every positive number. 0 is
equivalent -1 of previous versions of the module.
</dd>
<p></p>
<dt><strong><a name="item_header">header</a></strong><br />
</dt>
<dd>
<strong>HTTP header</strong> uses as value by default before main content template print.
</dd>
<dd>
<pre>
    my $template = new TemplateM( -header =&gt; &quot;Content-type: text/html; charset=UTF-8\n\n&quot;);
    print $template-&gt;html;</pre>
</dd>
<p></p>
<dt><strong><a name="item_template">template</a></strong><br />
</dt>
<dd>
<strong>HTTP content</strong> (template). This attribute has to be defined when template content is not
able to get from a file or get it from remote locations. E.g. it has to be defined when
a template selects from a database. Defining of this attribute means disabling of
precompile result caching!
</dd>
<p></p></dl>
<p>
</p>
<h2><a name="default_scheme_methods_(basic_methods)">DEFAULT SCHEME METHODS (BASIC METHODS)</a></h2>
<p>It is enough to define the module without parameters for using of basic methods.</p>
<pre>
    use TemplateM;</pre>
<p>After that only basic metods will be automatically enabled.</p>
<p>
</p>
<h3><a name="cast">cast</a></h3>
<p>Modification of labels (cgi labels)</p>
<pre>
    $template-&gt;cast({label1=&gt;value1, label2=&gt;value2, ... });</pre>
<dl>
<dt><strong><a name="item_label">label</a></strong><br />
</dt>
<dd>
<strong>Label</strong> - name will be replaced with appropriate <a href="#item_value">value</a> in tag &lt;!-- cgi: label --&gt;
</dd>
<p></p>
<dt><strong><a name="item_value">value</a></strong><br />
</dt>
<dd>
<strong>Value</strong> - Value, which CGI-script sets. Member of <a href="#label">the label manpage</a>
</dd>
<p></p></dl>
<p>
</p>
<h3><a name="cast_loop">cast_loop</a></h3>
<p>Block labels modification (val labels)</p>
<pre>
    $template-&gt;cast_loop (block_label, {label1=&gt;value1, label2=&gt;value2, ... }]);</pre>
<dl>
<dt><strong><a name="item_block_label">block_label</a></strong><br />
</dt>
<dd>
<strong>Block label</strong> - Block identification name.
The name will be inserted in tags &lt;!-- do: block_label --&gt; and &lt;!-- loop: block_label --&gt; - all content
between this tags processes like labels, but the tag will be formed as &lt;!-- val: label --&gt;
</dd>
<p></p></dl>
<p>
</p>
<h3><a name="finalize">finalize</a></h3>
<p>Block finalizing</p>
<pre>
    $template-&gt;finalize(block_label);
    
Block finalizing uses for not-processed blocks deleting. You need use finalizing every time you use blockes.</pre>
<p>
</p>
<h3><a name="cast_if">cast_if</a></h3>
<pre>
    $template-&gt;cast_if(ifblock_label, predicate);</pre>
<p>Method analyses boolean value of predicate. If value is true, the method prints if-structure content only.</p>
<pre>
    &lt;!-- if: label --&gt;
        ... blah blah blah ...
    &lt;!-- end_if: label --&gt;</pre>
<p>otherwise the method prints else-structure content only.</p>
<pre>
    &lt;!-- else: label --&gt;
        ... blah blah blah ...
    &lt;!-- end_else: label --&gt;</pre>
<p>
</p>
<h3><a name="html">html</a></h3>
<p>Template finalizing</p>
<pre>
    print $template-&gt;html(-header=&gt;HTTP_header);
    print $template-&gt;html(HTTP_header);
    print $template-&gt;html;</pre>
<p>The procedure will return formed document after template processing.
if header is present as argument it will be added at the beginning of template's return.</p>
<p>
</p>
<h2><a name="galore_scheme_methods">GALORE SCHEME METHODS</a></h2>
<p>It is enough to define the module with parameter 'galore' for using of galore scheme methods.</p>
<pre>
    use TemplateM 'galore';</pre>
<p>
</p>
<h3><a name="stash">stash</a></h3>
<p>stash (or cast) method is the function of import variables value into template.</p>
<pre>
    $template-&gt;stash(title =&gt; 'PI' , pi =&gt; 3.1415926);</pre>
<p>This example demonstrate how all of &lt;!-- cgi: title --&gt; and &lt;!-- cgi: pi --&gt; structures
will be replaced by parameters of stash method invoking.</p>
<p>In contrast to default scheme, in galore scheme stash method process directives &lt;!-- cgi: label --&gt; only
with defined labels when invoking, whereas cast method of default scheme precess all of
directives &lt;!-- cgi: label --&gt; in template!</p>
<p>
</p>
<h3><a name="start_and_finish">start and finish</a></h3>
<p>Start method defines the beginning of loop, and finish method defines the end.
Start method returns reference to the subtemplate object, that is all between do and loop directives.</p>
<pre>
    &lt;!-- do: block_label --&gt;
        ... blah blah blah ...
            &lt;!-- val: label1 --&gt;
            &lt;!-- val: label2 --&gt;
            &lt;!-- cgi: label --&gt;
        ... blah blah blah ...
    &lt;!-- loop: block_label --&gt;</pre>
<pre>
    my $block = $template-&gt;start(block_label);
    ...
    $block-&gt;finish;</pre>
<p>For acces to val directives it is necessary to use loop method, and for access to cgi directives use stash method.</p>
<p>
</p>
<h3><a name="loop">loop</a></h3>
<p>The method takes as parameters a hash of arguments or a reference to this hash.</p>
<pre>
    $block-&gt;loop(label1 =&gt; 'A', label2 =&gt; 'B');
    $block-&gt;loop({label1 =&gt; 'A', label2 =&gt; 'B'});</pre>
<p>Stash method also can be invoked in $block object context.</p>
<pre>
    $block-&gt;stash(label =&gt; 3.1415926);</pre>
<p>
</p>
<h3><a name="ifelse">ifelse</a></h3>
<pre>
    $template-&gt;ifelse(&quot;ifblock_label&quot;, $predicate)
    $block-&gt;ifelse(&quot;ifblock_label&quot;, $predicate)</pre>
<p>Method is equal to cast_if method of default scheme. The difference, ifelse method
can be processed with $template or $block, whereas cast_if method has deal with $template object.</p>
<p>
</p>
<h3><a name="output">output</a></h3>
<p>The method returns result of template processing. Output method has deal with $template and $block object:</p>
<pre>
    $block-&gt;output;
    $template-&gt;output;</pre>
<p>
</p>
<h3><a name="html">html</a></h3>
<p>The method is completely equal to html method of default scheme.</p>
<p>
</p>
<h2><a name="templatem's_and_ssi_directives">TEMPLATEM'S AND SSI DIRECTIVES</a></h2>
<p>The module can be used with SSI directives together, like in this shtml-sample:
</p>
<pre>

    &lt;html&gt;
        &lt;!--#include virtual=&quot;head.htm&quot;--&gt;
    &lt;body&gt;
        &lt;center&gt;&lt;!-- cgi: head --&gt;&lt;center&gt;
        &lt;!-- do: BLOCK_P --&gt;
            &lt;p&gt;&lt;!-- val: content --&gt;&lt;/p&gt;
        &lt;!-- loop: BLOCK_P --&gt;
    &lt;/body&gt;
    &lt;/html&gt;</pre>
<p>
</p>
<hr />
<h1><a name="environment">ENVIRONMENT</a></h1>
<p>No environment variables are used.</p>
<p>
</p>
<hr />
<h1><a name="bugs">BUGS</a></h1>
<p>Please report them.</p>
<p>
</p>
<hr />
<h1><a name="see_also">SEE ALSO</a></h1>
<p>LWP, CGI</p>
<p>
</p>
<hr />
<h1><a name="diagnostics">DIAGNOSTICS</a></h1>
<p>The usual warnings if it cannot read or write the files involved.</p>
<p>
</p>
<hr />
<h1><a name="history">HISTORY</a></h1>
<p>1.00 Initial release</p>
<p>1.10 Working with cache ability is added</p>
<p>1.11 Inner method's interface had structured</p>
<p>1.21 New time managment for templates caching. You can set how long template file will be cached before renew.</p>
<p>2.00 New abilities</p>
<pre>
    * Simultaneous templates using errors is eliminated.
    * Alternate interface of using methods is added.
    * Method of conditional representation of template CAST_IF is added.</pre>
<p>2.01 Cache-file access errors corrected</p>
<p>2.20 Module structure has rebuilt and changes has done</p>
<pre>
    * galore scheme added
    * update method deleted and constructor interface changed
    * errors of cachefile compiling was corrected
      (prefix is deleted, CRLF consecution output is corrected)
    * UTF-8 codepage for templates added
    * mod_perl 1.00 and 2.00 support added</pre>
<p>
</p>
<hr />
<h1><a name="todo">TODO</a></h1>
<pre>
    * simultaneous multiple declared do-loop structure blocks processing.</pre>
<p>
</p>
<hr />
<h1><a name="thanks">THANKS</a></h1>
<p>Thanks to Dmitry Klimov for technical translating <code>http://fla-master.com</code>.</p>
<p>
</p>
<hr />
<h1><a name="author">AUTHOR</a></h1>
<p>Lepenkov Sergey (Serz Minus), <code>minus@mail333.com</code></p>
<p>
</p>
<hr />
<h1><a name="copyrights">COPYRIGHTS</a></h1>
<p>Copyright (C) 1998-2008 D&amp;D Corporation. All Rights Reserved

</p>

</body>

</html>
